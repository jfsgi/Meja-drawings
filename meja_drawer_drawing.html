<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>MEJA Designs - Drawer Box Drawing</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    font-family: 'Segoe UI', Arial, sans-serif;
    background: #f5f5f5;
    color: #333;
  }
  .header {
    background: #1a1a2e;
    color: white;
    padding: 12px 24px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  .header h1 { font-size: 18px; font-weight: 600; letter-spacing: 1px; }
  .header .subtitle { font-size: 12px; opacity: 0.7; }
  .controls {
    background: white;
    padding: 16px 24px;
    border-bottom: 1px solid #ddd;
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
    align-items: flex-end;
  }
  .control-group { display: flex; flex-direction: column; gap: 4px; }
  .control-group label {
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
    color: #666;
    letter-spacing: 0.5px;
  }
  .control-group input[type="number"] {
    width: 90px;
    padding: 6px 8px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-size: 14px;
  }
  .control-group input[type="number"]:focus {
    outline: none;
    border-color: #1a1a2e;
  }
  .toggle-group {
    display: flex;
    gap: 12px;
    align-items: center;
    padding: 6px 0;
  }
  .toggle-label {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 13px;
    cursor: pointer;
  }
  .toggle-label input[type="checkbox"] {
    width: 16px;
    height: 16px;
    accent-color: #1a1a2e;
  }
  .separator {
    width: 1px;
    height: 40px;
    background: #ddd;
    align-self: center;
  }
  .btn {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
    font-weight: 600;
  }
  .btn-print {
    background: #1a1a2e;
    color: white;
  }
  .btn-print:hover { background: #2a2a4e; }
  .drawing-area {
    display: grid;
    grid-template-columns: 1fr 1fr;
    grid-template-rows: auto auto;
    gap: 16px;
    padding: 16px 24px;
  }
  .view-panel {
    background: white;
    border: 1px solid #ddd;
    border-radius: 6px;
    overflow: hidden;
  }
  .view-panel .view-title {
    background: #eee;
    padding: 8px 12px;
    font-size: 12px;
    font-weight: 700;
    text-transform: uppercase;
    letter-spacing: 1px;
    color: #555;
    border-bottom: 1px solid #ddd;
  }
  .view-panel svg {
    width: 100%;
    height: 100%;
    display: block;
  }
  .view-container {
    padding: 12px;
    height: 340px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .iso-panel {
    grid-column: 1 / -1;
  }
  .iso-panel .view-container {
    height: 400px;
  }
  .spec-table {
    grid-column: 1 / -1;
    background: white;
    border: 1px solid #ddd;
    border-radius: 6px;
    overflow: hidden;
  }
  .spec-table table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
  }
  .spec-table th {
    background: #eee;
    padding: 8px 12px;
    text-align: left;
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: #555;
    border-bottom: 1px solid #ddd;
  }
  .spec-table td {
    padding: 6px 12px;
    border-bottom: 1px solid #f0f0f0;
  }

  /* Dimension lines */
  .dim-line { stroke: #e63946; stroke-width: 0.5; }
  .dim-arrow { fill: #e63946; }
  .dim-text {
    font-family: 'Segoe UI', Arial, sans-serif;
    font-size: 10px;
    fill: #e63946;
    text-anchor: middle;
  }
  .dim-text-small { font-size: 8px; }
  .outline { stroke: #333; stroke-width: 1; fill: none; }
  .outline-thick { stroke: #333; stroke-width: 1.5; fill: none; }
  .outline-thin { stroke: #666; stroke-width: 0.5; fill: none; }
  .outline-dashed { stroke: #999; stroke-width: 0.5; stroke-dasharray: 3,2; fill: none; }
  .fill-light { fill: #f9f3e8; }
  .fill-side { fill: #e8dcc8; }
  .fill-top { fill: #f0e6d2; }
  .fill-inner { fill: #fff8ee; }
  .dovetail-line { stroke: #8B4513; stroke-width: 0.6; fill: none; }
  .cutout-fill { fill: #f5f5f5; stroke: #333; stroke-width: 0.8; }
  .scoop-fill { fill: none; stroke: #333; stroke-width: 0.8; stroke-dasharray: 4,2; }
  .notch-fill { fill: #f5f5f5; stroke: #333; stroke-width: 0.8; }
  .label-text {
    font-family: 'Segoe UI', Arial, sans-serif;
    font-size: 8px;
    fill: #666;
    text-anchor: middle;
  }
  .feature-label {
    font-family: 'Segoe UI', Arial, sans-serif;
    font-size: 7px;
    fill: #0066cc;
    text-anchor: middle;
  }

  /* Print styles */
  @media print {
    body { background: white; }
    .controls { display: none; }
    .header { background: #333; padding: 8px 16px; }
    .drawing-area { padding: 8px; gap: 8px; }
    .view-container { height: auto !important; min-height: 250px; }
    .iso-panel .view-container { min-height: 300px; }
  }
</style>
</head>
<body>

<div class="header">
  <div style="display:flex;align-items:center;gap:12px">
    <img src="meja_logo.png" alt="MEJA Designs" style="height:44px;width:auto">
    <div>
      <h1>MEJA DESIGNS</h1>
      <div class="subtitle">Custom Drawer Box - Technical Drawing</div>
    </div>
  </div>
  <div style="text-align:right">
    <div id="dateDisplay" style="font-size:12px;opacity:0.7"></div>
    <div id="orderDisplay" style="font-size:12px;opacity:0.7"></div>
  </div>
</div>

<div class="controls">
  <div class="control-group">
    <label>Width (in)</label>
    <input type="number" id="dimWidth" value="24" min="3" max="60" step="0.125" onchange="updateDrawing()">
  </div>
  <div class="control-group">
    <label>Length / Depth (in)</label>
    <input type="number" id="dimLength" value="21" min="3" max="36" step="0.125" onchange="updateDrawing()">
  </div>
  <div class="control-group">
    <label>Height (in)</label>
    <input type="number" id="dimHeight" value="7" min="2" max="16" step="0.125" onchange="updateDrawing()">
  </div>
  <div class="control-group">
    <label>Thickness (in)</label>
    <input type="number" id="dimThick" value="0.5625" min="0.25" max="1" step="0.0625" onchange="updateDrawing()">
  </div>

  <div class="separator"></div>

  <div class="control-group">
    <label>Features</label>
    <div class="toggle-group">
      <label class="toggle-label">
        <input type="checkbox" id="togPull" checked onchange="updateDrawing()"> Pull Cutout
      </label>
      <label class="toggle-label">
        <input type="checkbox" id="togScoop" checked onchange="updateDrawing()"> Scoop Front
      </label>
      <label class="toggle-label">
        <input type="checkbox" id="togNotch" checked onchange="updateDrawing()"> Undermount Notches
      </label>
    </div>
  </div>

  <div class="separator"></div>

  <div class="control-group">
    <label>Pull Cutout Width (in)</label>
    <input type="number" id="pullWidth" value="4" min="1" max="12" step="0.125" onchange="updateDrawing()">
  </div>
  <div class="control-group">
    <label>Pull Depth (in)</label>
    <input type="number" id="pullDepth" value="1.5" min="0.5" max="4" step="0.125" onchange="updateDrawing()">
  </div>
  <div class="control-group">
    <label>Scoop Depth (in)</label>
    <input type="number" id="scoopDepth" value="1" min="0.5" max="3" step="0.125" onchange="updateDrawing()">
  </div>

  <div class="separator"></div>

  <button class="btn btn-print" onclick="window.print()">Print / Save PDF</button>
</div>

<div class="drawing-area">
  <!-- Top View -->
  <div class="view-panel">
    <div class="view-title">Top View</div>
    <div class="view-container" id="topViewContainer"></div>
  </div>

  <!-- Front View -->
  <div class="view-panel">
    <div class="view-title">Front View</div>
    <div class="view-container" id="frontViewContainer"></div>
  </div>

  <!-- Isometric View -->
  <div class="view-panel iso-panel">
    <div class="view-title">Isometric View</div>
    <div class="view-container" id="isoViewContainer"></div>
  </div>

  <!-- Spec Table -->
  <div class="spec-table">
    <table>
      <tr>
        <th>Dimension</th><th>Value</th><th>Feature</th><th>Status</th>
      </tr>
      <tbody id="specBody"></tbody>
    </table>
  </div>
</div>

<script>
// ============================================================
// MEJA Designs - Drawer Box Technical Drawing Generator
// For use in FileMaker Web Viewer
// ============================================================

function getInputs() {
  return {
    W: parseFloat(document.getElementById('dimWidth').value) || 24,
    L: parseFloat(document.getElementById('dimLength').value) || 21,
    H: parseFloat(document.getElementById('dimHeight').value) || 7,
    T: parseFloat(document.getElementById('dimThick').value) || 0.5625,
    pullCutout: document.getElementById('togPull').checked,
    scoopFront: document.getElementById('togScoop').checked,
    undermountNotch: document.getElementById('togNotch').checked,
    pullW: parseFloat(document.getElementById('pullWidth').value) || 4,
    pullD: parseFloat(document.getElementById('pullDepth').value) || 1.5,
    scoopD: parseFloat(document.getElementById('scoopDepth').value) || 1,
  };
}

// Helper: create SVG element
function svgEl(tag, attrs) {
  const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
  for (const [k, v] of Object.entries(attrs || {})) {
    el.setAttribute(k, v);
  }
  return el;
}

// Helper: dimension line with arrows and text
function dimLine(svg, x1, y1, x2, y2, label, offset, side, name) {
  // side: 'top','bottom','left','right' determines offset direction
  // name: optional dimension name label (e.g. 'WIDTH', 'HEIGHT')
  const g = svgEl('g');
  let ox = 0, oy = 0;
  if (side === 'top') oy = -offset;
  else if (side === 'bottom') oy = offset;
  else if (side === 'left') ox = -offset;
  else if (side === 'right') ox = offset;

  const lx1 = x1 + ox, ly1 = y1 + oy;
  const lx2 = x2 + ox, ly2 = y2 + oy;

  // Extension lines
  g.appendChild(svgEl('line', { x1, y1, x2: lx1, y2: ly1, class: 'dim-line' }));
  g.appendChild(svgEl('line', { x1: x2, y1: y2, x2: lx2, y2: ly2, class: 'dim-line' }));

  // Main dim line
  g.appendChild(svgEl('line', { x1: lx1, y1: ly1, x2: lx2, y2: ly2, class: 'dim-line' }));

  // Arrows
  const arrowSize = 2;
  const dx = lx2 - lx1, dy = ly2 - ly1;
  const len = Math.sqrt(dx * dx + dy * dy);
  if (len > 0) {
    const ux = dx / len, uy = dy / len;
    const px = -uy, py = ux;
    // Arrow at start
    g.appendChild(svgEl('polygon', {
      points: `${lx1},${ly1} ${lx1 + ux * arrowSize + px * arrowSize * 0.4},${ly1 + uy * arrowSize + py * arrowSize * 0.4} ${lx1 + ux * arrowSize - px * arrowSize * 0.4},${ly1 + uy * arrowSize - py * arrowSize * 0.4}`,
      class: 'dim-arrow'
    }));
    // Arrow at end
    g.appendChild(svgEl('polygon', {
      points: `${lx2},${ly2} ${lx2 - ux * arrowSize + px * arrowSize * 0.4},${ly2 - uy * arrowSize + py * arrowSize * 0.4} ${lx2 - ux * arrowSize - px * arrowSize * 0.4},${ly2 - uy * arrowSize - py * arrowSize * 0.4}`,
      class: 'dim-arrow'
    }));
  }

  // Text
  const tx = (lx1 + lx2) / 2, ty = (ly1 + ly2) / 2;
  const isVertical = (side === 'left' || side === 'right');
  const txt = svgEl('text', {
    x: tx,
    y: ty - 2,
    class: 'dim-text'
  });
  txt.textContent = label;
  g.appendChild(txt);

  // Optional dimension name label
  if (name) {
    const nameTxt = svgEl('text', {
      x: isVertical ? tx : tx,
      y: isVertical ? ty + 9 : ty + 8,
      class: 'dim-text dim-text-small'
    });
    nameTxt.textContent = name;
    g.appendChild(nameTxt);
  }

  svg.appendChild(g);
}

// Format dimension as fraction
function fmtDim(val) {
  const whole = Math.floor(val);
  const frac = val - whole;
  if (frac < 0.01) return whole + '"';

  const fractions = [
    [1/16, '1/16'], [1/8, '1/8'], [3/16, '3/16'], [1/4, '1/4'],
    [5/16, '5/16'], [3/8, '3/8'], [7/16, '7/16'], [1/2, '1/2'],
    [9/16, '9/16'], [5/8, '5/8'], [11/16, '11/16'], [3/4, '3/4'],
    [13/16, '13/16'], [7/8, '7/8'], [15/16, '15/16']
  ];

  let closest = fractions[0];
  let minDiff = Math.abs(frac - fractions[0][0]);
  for (const f of fractions) {
    const d = Math.abs(frac - f[0]);
    if (d < minDiff) { minDiff = d; closest = f; }
  }

  if (whole === 0) return closest[1] + '"';
  return whole + '-' + closest[1] + '"';
}


// ============================================================
// TOP VIEW
// ============================================================
function drawTopView(d) {
  const container = document.getElementById('topViewContainer');
  container.innerHTML = '';

  const margin = 30;
  const scale = Math.min(
    (container.clientWidth - margin * 2) / d.W,
    (container.clientHeight - margin * 2) / d.L
  ) * 0.75;

  const sw = d.W * scale, sl = d.L * scale;
  const st = d.T * scale;
  const vw = sw + margin * 2, vh = sl + margin * 2;

  const svg = svgEl('svg', {
    viewBox: `0 0 ${vw} ${vh}`,
    width: '100%',
    height: '100%',
    preserveAspectRatio: 'xMidYMid meet'
  });

  const ox = margin, oy = margin;

  // Outer rectangle (box exterior)
  svg.appendChild(svgEl('rect', {
    x: ox, y: oy, width: sw, height: sl,
    class: 'outline-thick fill-light'
  }));

  // Inner rectangle (cavity)
  svg.appendChild(svgEl('rect', {
    x: ox + st, y: oy + st, width: sw - st * 2, height: sl - st * 2,
    class: 'outline fill-inner'
  }));

  // Dovetail markers on corners
  const dtSize = Math.min(st * 2.5, 8);
  const corners = [
    [ox, oy], [ox + sw, oy], [ox, oy + sl], [ox + sw, oy + sl]
  ];
  for (const [cx, cy] of corners) {
    // Small dovetail zigzag marks at corners
    const dx = cx === ox ? 1 : -1;
    const dy = cy === oy ? 1 : -1;
    const path = `M${cx},${cy + dy * 2} l${dx * dtSize * 0.3},${dy * dtSize * 0.4} l${-dx * dtSize * 0.3},${dy * dtSize * 0.4}`;
    svg.appendChild(svgEl('path', { d: path, class: 'dovetail-line' }));
    const path2 = `M${cx + dx * 2},${cy} l${dx * dtSize * 0.4},${dy * dtSize * 0.3} l${dx * dtSize * 0.4},${-dy * dtSize * 0.3}`;
    svg.appendChild(svgEl('path', { d: path2, class: 'dovetail-line' }));
  }

  // Pull cutout on front edge (bottom of top view = front of box)
  if (d.pullCutout) {
    const pw = d.pullW * scale;
    const pd = d.pullD * scale;
    const pcx = ox + sw / 2 - pw / 2;
    const pcy = oy + sl - pd;
    const r = Math.min(1 * scale, pd * 0.35, pw / 4); // R1" radius scaled
    // U-shape with rounded corners and curved bottom
    const curveDepth = pd * 0.15; // how much the bottom curves down in center
    const cutPath = `M${pcx},${oy + sl} L${pcx},${pcy + r} A${r},${r} 0 0 1 ${pcx + r},${pcy} Q${ox + sw / 2},${pcy - curveDepth} ${pcx + pw - r},${pcy} A${r},${r} 0 0 1 ${pcx + pw},${pcy + r} L${pcx + pw},${oy + sl}`;
    svg.appendChild(svgEl('path', { d: cutPath, class: 'cutout-fill' }));

    // Label
    const lbl = svgEl('text', {
      x: ox + sw / 2, y: pcy - curveDepth - 3,
      class: 'feature-label'
    });
    lbl.textContent = 'PULL CUTOUT';
    svg.appendChild(lbl);
  }

  // Undermount notches (rear bottom corners in top view = top of drawing)
  if (d.undermountNotch) {
    const nw = 2.5 * scale; // notch width
    const nd = 1 * scale;   // notch depth
    // Left rear
    svg.appendChild(svgEl('rect', {
      x: ox, y: oy, width: nw, height: nd,
      class: 'notch-fill'
    }));
    // Right rear
    svg.appendChild(svgEl('rect', {
      x: ox + sw - nw, y: oy, width: nw, height: nd,
      class: 'notch-fill'
    }));

    const lbl = svgEl('text', {
      x: ox + sw / 2, y: oy + nd + 8,
      class: 'feature-label'
    });
    lbl.textContent = 'UNDERMOUNT NOTCHES (REAR)';
    svg.appendChild(lbl);
  }

  // Dimension lines
  dimLine(svg, ox, oy, ox + sw, oy, fmtDim(d.W), 18, 'top', 'WIDTH');
  dimLine(svg, ox, oy, ox, oy + sl, fmtDim(d.L), 18, 'left', 'LENGTH');

  // Thickness dimension
  dimLine(svg, ox, oy + sl + 3, ox + st, oy + sl + 3, fmtDim(d.T), 20, 'bottom', 'THICKNESS');

  // Labels
  const topLabel = svgEl('text', {
    x: ox + sw / 2, y: oy + sl / 2,
    class: 'label-text', 'font-size': '10px'
  });
  topLabel.textContent = 'INTERIOR';
  svg.appendChild(topLabel);

  // Front/rear labels
  const frontLbl = svgEl('text', {
    x: ox + sw / 2, y: oy + sl + 10,
    class: 'label-text', 'font-size': '7px'
  });
  frontLbl.textContent = 'FRONT';
  svg.appendChild(frontLbl);

  const rearLbl = svgEl('text', {
    x: ox + sw / 2, y: oy - 3,
    class: 'label-text', 'font-size': '7px'
  });
  rearLbl.textContent = 'REAR';
  svg.appendChild(rearLbl);

  container.appendChild(svg);
}


// ============================================================
// FRONT VIEW
// ============================================================
function drawFrontView(d) {
  const container = document.getElementById('frontViewContainer');
  container.innerHTML = '';

  const margin = 30;
  const scale = Math.min(
    (container.clientWidth - margin * 2) / d.W,
    (container.clientHeight - margin * 2) / d.H
  ) * 0.75;

  const sw = d.W * scale, sh = d.H * scale;
  const st = d.T * scale;
  const vw = sw + margin * 2, vh = sh + margin * 2;

  const svg = svgEl('svg', {
    viewBox: `0 0 ${vw} ${vh}`,
    width: '100%',
    height: '100%',
    preserveAspectRatio: 'xMidYMid meet'
  });

  const ox = margin, oy = margin;
  const bottomRaise = 0.5 * scale; // bottom panel raised 1/2" from bottom edge (dado groove)
  const scoopFrontSD = d.scoopFront ? d.scoopD * scale : 0;
  const frontWallTop = oy + scoopFrontSD; // top of the front wall (lower when scooped)

  if (d.scoopFront) {
    // Full box outline (side/back walls at full height)
    svg.appendChild(svgEl('rect', {
      x: ox, y: oy, width: sw, height: sh,
      class: 'outline-thick', fill: 'none'
    }));

    // Front wall fill (lower portion only)
    svg.appendChild(svgEl('rect', {
      x: ox, y: frontWallTop, width: sw, height: sh - scoopFrontSD,
      class: 'fill-light', stroke: 'none'
    }));

    // Interior visible above front wall (back wall face)
    svg.appendChild(svgEl('rect', {
      x: ox + st, y: oy, width: sw - 2 * st, height: scoopFrontSD,
      fill: '#fff8ee', stroke: 'none'
    }));

    // Side walls extending above front wall (full height strips)
    svg.appendChild(svgEl('rect', {
      x: ox, y: oy, width: st, height: scoopFrontSD,
      fill: '#e8dcc8', stroke: '#666', 'stroke-width': 0.5
    }));
    svg.appendChild(svgEl('rect', {
      x: ox + sw - st, y: oy, width: st, height: scoopFrontSD,
      fill: '#e8dcc8', stroke: '#666', 'stroke-width': 0.5
    }));

    // Front wall top edge (prominent line)
    svg.appendChild(svgEl('line', {
      x1: ox + st, y1: frontWallTop,
      x2: ox + sw - st, y2: frontWallTop,
      stroke: '#333', 'stroke-width': 1.5
    }));

    // Re-draw outer box outline on top
    svg.appendChild(svgEl('rect', {
      x: ox, y: oy, width: sw, height: sh,
      class: 'outline-thick', fill: 'none'
    }));

    // Scoop label
    var scoopLbl = svgEl('text', {
      x: ox + sw / 2, y: oy + scoopFrontSD / 2 + 3,
      class: 'feature-label'
    });
    scoopLbl.textContent = 'SCOOP';
    svg.appendChild(scoopLbl);
  } else {
    // Outer rectangle (front face - solid, visible)
    svg.appendChild(svgEl('rect', {
      x: ox, y: oy, width: sw, height: sh,
      class: 'outline-thick fill-light'
    }));
  }

  // --- HIDDEN LINES (dashed, lighter - features behind front face) ---

  // Side wall thickness lines (hidden behind front panel)
  // Left side wall inner edge
  svg.appendChild(svgEl('line', {
    x1: ox + st, y1: oy, x2: ox + st, y2: oy + sh,
    class: 'outline-dashed'
  }));
  // Right side wall inner edge
  svg.appendChild(svgEl('line', {
    x1: ox + sw - st, y1: oy, x2: ox + sw - st, y2: oy + sh,
    class: 'outline-dashed'
  }));

  // Bottom panel (raised - sits in dado groove)
  // Top edge of bottom panel
  svg.appendChild(svgEl('line', {
    x1: ox, y1: oy + sh - bottomRaise - st,
    x2: ox + sw, y2: oy + sh - bottomRaise - st,
    class: 'outline-dashed'
  }));
  // Bottom edge of bottom panel (where dado groove starts)
  svg.appendChild(svgEl('line', {
    x1: ox, y1: oy + sh - bottomRaise,
    x2: ox + sw, y2: oy + sh - bottomRaise,
    class: 'outline-dashed'
  }));

  // Pull cutout on front face (U-shape with R1" corners and curved bottom)
  if (d.pullCutout) {
    const pw = d.pullW * scale;
    const pd = d.pullD * scale;
    const pcx = ox + sw / 2 - pw / 2;
    const pTop = frontWallTop; // top of front wall (adjusted for scoop)
    const r = Math.min(1 * scale, pd * 0.35, pw / 4); // R1" radius
    const curveDepth = pd * 0.15; // curved bottom dip
    const cutPath = `M${pcx},${pTop} L${pcx},${pTop + pd - r} A${r},${r} 0 0 0 ${pcx + r},${pTop + pd} Q${ox + sw / 2},${pTop + pd + curveDepth} ${pcx + pw - r},${pTop + pd} A${r},${r} 0 0 0 ${pcx + pw},${pTop + pd - r} L${pcx + pw},${pTop}`;
    svg.appendChild(svgEl('path', { d: cutPath, class: 'cutout-fill' }));

    // Pull dim
    dimLine(svg, pcx, pTop, pcx + pw, pTop, fmtDim(d.pullW), -3, 'top');
  }

  // Scoop front rendering is handled in the initial rectangle section above

  // Undermount notches (on back wall - hidden, shown as dashed)
  if (d.undermountNotch) {
    const nw = 2.5 * scale;
    const nh = 0.5 * scale;
    svg.appendChild(svgEl('rect', {
      x: ox, y: oy + sh - nh, width: nw, height: nh,
      fill: 'none', stroke: '#999', 'stroke-width': 0.5, 'stroke-dasharray': '3,2'
    }));
    svg.appendChild(svgEl('rect', {
      x: ox + sw - nw, y: oy + sh - nh, width: nw, height: nh,
      fill: 'none', stroke: '#999', 'stroke-width': 0.5, 'stroke-dasharray': '3,2'
    }));
    // Label
    const nlbl = svgEl('text', {
      x: ox + sw / 2, y: oy + sh - nh - 2,
      class: 'feature-label', 'font-size': '6px', fill: '#999'
    });
    nlbl.textContent = 'UNDERMOUNT NOTCHES (HIDDEN)';
    svg.appendChild(nlbl);
  }

  // Dimensions
  dimLine(svg, ox, oy, ox + sw, oy, fmtDim(d.W), 18, 'top', 'WIDTH');
  dimLine(svg, ox + sw, oy, ox + sw, oy + sh, fmtDim(d.H), 18, 'right', 'HEIGHT');
  // Thickness
  dimLine(svg, ox, oy + sh, ox + st, oy + sh, fmtDim(d.T), 22, 'bottom', 'THICKNESS');

  // Bottom raise dimension
  const brLabel = svgEl('text', {
    x: ox + sw - st - 4, y: oy + sh - bottomRaise / 2,
    class: 'dim-text dim-text-small', 'text-anchor': 'end', fill: '#999'
  });
  brLabel.textContent = 'RAISED BOTTOM';
  svg.appendChild(brLabel);

  container.appendChild(svg);
}


// ============================================================
// ISOMETRIC VIEW
// ============================================================
function drawIsoView(d) {
  const container = document.getElementById('isoViewContainer');
  container.innerHTML = '';

  const margin = 60;
  const maxDim = Math.max(d.W, d.L, d.H);
  const scale = Math.min(
    (container.clientWidth - margin * 2) / (maxDim * 1.8),
    (container.clientHeight - margin * 2) / (maxDim * 1.5)
  ) * 0.7;

  // Isometric projection angles (30 degrees)
  const cos30 = Math.cos(Math.PI / 6); // 0.866
  const sin30 = 0.5;

  // NOTE: x-axis = Length (depth, front-to-back), y-axis = Width (side-to-side)
  // This ensures the front face shows Width and the side face shows Length
  const sw = d.L * scale, sl = d.W * scale, sh = d.H * scale;
  const st = d.T * scale;

  // Project 3D point to 2D isometric
  function iso(x, y, z) {
    return [
      margin + sl * cos30 + x * cos30 - y * cos30,
      margin + x * sin30 + y * sin30 - z + sh
    ];
  }

  const totalW = (d.W + d.L) * cos30 * scale + margin * 2;
  const totalH = (d.W + d.L) * sin30 * scale + d.H * scale + margin * 2;

  const svg = svgEl('svg', {
    viewBox: `0 0 ${totalW} ${totalH}`,
    width: '100%',
    height: '100%',
    preserveAspectRatio: 'xMidYMid meet'
  });

  // Scoop profile calculation
  var scoopSD = d.scoopFront ? d.scoopD * scale : 0;
  var frontH = d.scoopFront ? sh - scoopSD : sh;
  function scoopZ(xPos) {
    if (!d.scoopFront || xPos / sw < 0.5) return sh;
    var u = (xPos / sw - 0.5) / 0.5;
    return sh - scoopSD * (1 - Math.cos(u * Math.PI / 2));
  }

  // Bottom face (floor of box)
  const bf = [iso(0, 0, 0), iso(sw, 0, 0), iso(sw, sl, 0), iso(0, sl, 0)];
  svg.appendChild(svgEl('polygon', {
    points: bf.map(p => p.join(',')).join(' '),
    fill: '#e8dcc8', stroke: '#333', 'stroke-width': 1
  }));

  // Back wall (left side in iso - the length/depth wall)
  const bw = [iso(0, 0, 0), iso(0, sl, 0), iso(0, sl, sh), iso(0, 0, sh)];
  svg.appendChild(svgEl('polygon', {
    points: bw.map(p => p.join(',')).join(' '),
    fill: '#ddd0b8', stroke: '#333', 'stroke-width': 1
  }));

  // Left wall (visible side wall - follows scoop profile)
  (function() {
    var pts = [iso(0, sl, 0), iso(sw, sl, 0)];
    if (d.scoopFront) {
      var numPts = 24;
      for (var i = numPts; i >= 0; i--) {
        pts.push(iso((i / numPts) * sw, sl, scoopZ((i / numPts) * sw)));
      }
    } else {
      pts.push(iso(sw, sl, sh));
      pts.push(iso(0, sl, sh));
    }
    svg.appendChild(svgEl('polygon', {
      points: pts.map(function(p) { return p.join(','); }).join(' '),
      fill: '#c9b99a', stroke: '#333', 'stroke-width': 1
    }));
  })();

  // Right wall (hidden - follows scoop profile)
  (function() {
    var pts = [iso(0, 0, 0), iso(sw, 0, 0)];
    if (d.scoopFront) {
      var numPts = 24;
      for (var i = numPts; i >= 0; i--) {
        pts.push(iso((i / numPts) * sw, 0, scoopZ((i / numPts) * sw)));
      }
    } else {
      pts.push(iso(sw, 0, sh));
      pts.push(iso(0, 0, sh));
    }
    svg.appendChild(svgEl('polygon', {
      points: pts.map(function(p) { return p.join(','); }).join(' '),
      fill: '#d4c4a8', stroke: '#333', 'stroke-width': 0.5, 'stroke-dasharray': '3,2'
    }));
  })();

  // Front wall (shorter when scooped)
  const fw = [iso(sw, 0, 0), iso(sw, sl, 0), iso(sw, sl, frontH), iso(sw, 0, frontH)];
  svg.appendChild(svgEl('polygon', {
    points: fw.map(p => p.join(',')).join(' '),
    fill: '#f0e6d2', stroke: '#333', 'stroke-width': 1
  }));

  // Inner floor
  const ifl = [iso(st, st, st), iso(sw - st, st, st), iso(sw - st, sl - st, st), iso(st, sl - st, st)];
  svg.appendChild(svgEl('polygon', {
    points: ifl.map(p => p.join(',')).join(' '),
    fill: '#fff8ee', stroke: '#666', 'stroke-width': 0.5
  }));

  // Inner back wall top edge
  const ibTop = [iso(st, st, st), iso(st, st, sh), iso(st, sl - st, sh), iso(st, sl - st, st)];
  svg.appendChild(svgEl('polygon', {
    points: ibTop.map(p => p.join(',')).join(' '),
    fill: '#efe5d0', stroke: '#666', 'stroke-width': 0.5
  }));

  // Inner left wall (follows scoop profile)
  (function() {
    var pts = [iso(st, sl - st, st), iso(sw - st, sl - st, st)];
    if (d.scoopFront) {
      var numPts = 24;
      for (var i = numPts; i >= 0; i--) {
        var x = st + (i / numPts) * (sw - 2 * st);
        pts.push(iso(x, sl - st, scoopZ(x)));
      }
    } else {
      pts.push(iso(sw - st, sl - st, sh));
      pts.push(iso(st, sl - st, sh));
    }
    svg.appendChild(svgEl('polygon', {
      points: pts.map(function(p) { return p.join(','); }).join(' '),
      fill: '#e5d8c0', stroke: '#666', 'stroke-width': 0.5
    }));
  })();

  // Top edges of walls
  // Back wall top
  const bwTop = [iso(0, 0, sh), iso(st, 0, sh), iso(st, sl, sh), iso(0, sl, sh)];
  svg.appendChild(svgEl('polygon', {
    points: bwTop.map(p => p.join(',')).join(' '),
    fill: '#d8c8a8', stroke: '#333', 'stroke-width': 0.8
  }));

  // Left wall top strip (follows scoop curve)
  (function() {
    if (d.scoopFront) {
      var numPts = 24;
      var outerPts = [], innerPts = [];
      for (var i = 0; i <= numPts; i++) {
        var x = (i / numPts) * sw;
        var z = scoopZ(x);
        outerPts.push(iso(x, sl, z));
        innerPts.push(iso(x, sl - st, z));
      }
      svg.appendChild(svgEl('polygon', {
        points: outerPts.concat(innerPts.reverse()).map(function(p) { return p.join(','); }).join(' '),
        fill: '#d0c098', stroke: '#333', 'stroke-width': 0.8
      }));
    } else {
      var lwTop = [iso(0, sl, sh), iso(sw, sl, sh), iso(sw, sl - st, sh), iso(0, sl - st, sh)];
      svg.appendChild(svgEl('polygon', {
        points: lwTop.map(function(p) { return p.join(','); }).join(' '),
        fill: '#d0c098', stroke: '#333', 'stroke-width': 0.8
      }));
    }
  })();

  // Right wall top strip (follows scoop curve, hidden)
  (function() {
    if (d.scoopFront) {
      var numPts = 24;
      var outerPts = [], innerPts = [];
      for (var i = 0; i <= numPts; i++) {
        var x = (i / numPts) * sw;
        var z = scoopZ(x);
        outerPts.push(iso(x, 0, z));
        innerPts.push(iso(x, st, z));
      }
      svg.appendChild(svgEl('polygon', {
        points: outerPts.concat(innerPts.reverse()).map(function(p) { return p.join(','); }).join(' '),
        fill: '#d8c8a8', stroke: '#333', 'stroke-width': 0.5, 'stroke-dasharray': '2,1'
      }));
    } else {
      var rwTop = [iso(0, 0, sh), iso(sw, 0, sh), iso(sw, st, sh), iso(0, st, sh)];
      svg.appendChild(svgEl('polygon', {
        points: rwTop.map(function(p) { return p.join(','); }).join(' '),
        fill: '#d8c8a8', stroke: '#333', 'stroke-width': 0.5, 'stroke-dasharray': '2,1'
      }));
    }
  })();

  // Front wall top strip (at front height)
  var fwt = [iso(sw, 0, frontH), iso(sw, sl, frontH), iso(sw - st, sl, frontH), iso(sw - st, 0, frontH)];
  svg.appendChild(svgEl('polygon', {
    points: fwt.map(function(p) { return p.join(','); }).join(' '),
    fill: '#e0d4bc', stroke: '#333', 'stroke-width': 0.8
  }));

  // Scoop label
  if (d.scoopFront) {
    var sclblPt = iso(sw * 0.75, sl + 3, scoopZ(sw * 0.75));
    var sct = svgEl('text', {
      x: sclblPt[0] - 5, y: sclblPt[1] - 5,
      class: 'feature-label', 'font-size': '8px'
    });
    sct.textContent = 'SCOOP';
    svg.appendChild(sct);
  }

  // Pull cutout on front face
  if (d.pullCutout) {
    const pw = d.pullW * scale;
    const pd = d.pullD * scale;
    const startY = (sl - pw) / 2;
    const p1 = iso(sw, startY, sh);
    const p2 = iso(sw, startY, sh - pd);
    const p3 = iso(sw, startY + pw, sh - pd);
    const p4 = iso(sw, startY + pw, sh);
    svg.appendChild(svgEl('polygon', {
      points: [p1, p2, p3, p4].map(p => p.join(',')).join(' '),
      fill: '#f5f5f5', stroke: '#333', 'stroke-width': 0.8
    }));
    // Label
    const plbl = iso(sw + 1, startY + pw / 2, sh - pd / 2);
    const plt = svgEl('text', {
      x: plbl[0] + 10, y: plbl[1],
      class: 'feature-label', 'font-size': '8px'
    });
    plt.textContent = 'PULL CUTOUT';
    svg.appendChild(plt);
  }

  // Undermount notches on back wall bottom
  if (d.undermountNotch) {
    const nw = 2.5 * scale;
    const nh = 0.5 * scale;
    // Left notch (back wall, left side)
    const n1 = [iso(0, 0, 0), iso(0, nw, 0), iso(0, nw, nh), iso(0, 0, nh)];
    svg.appendChild(svgEl('polygon', {
      points: n1.map(p => p.join(',')).join(' '),
      fill: '#f5f5f5', stroke: '#333', 'stroke-width': 0.6
    }));
    // Right notch
    const n2 = [iso(0, sl - nw, 0), iso(0, sl, 0), iso(0, sl, nh), iso(0, sl - nw, nh)];
    svg.appendChild(svgEl('polygon', {
      points: n2.map(p => p.join(',')).join(' '),
      fill: '#f5f5f5', stroke: '#333', 'stroke-width': 0.6
    }));
  }

  // Realistic dovetail joints - SIDE FACE ONLY
  (function() {
    // Calculate dovetail pattern based on box height
    var numTails = Math.max(2, Math.min(6, Math.round(d.H / 1.8)));
    var pinRatio = 0.45;
    var halfPinRatio = 0.35;
    var totalUnits = numTails + (numTails - 1) * pinRatio + 2 * halfPinRatio;
    var tailH = sh / totalUnits;
    var pinH = tailH * pinRatio;
    var halfPinH = tailH * halfPinRatio;
    var taper = tailH * 0.13;

    var endGrain = '#c9a96e';
    var dtStroke = '#8B6914';
    var endGrainDark = '#b8985a';

    // Build pin positions (pins from front/back wall visible on side face)
    // Layout from bottom: halfpin, tail, pin, tail, pin, ..., tail, halfpin
    var pinZs = [];
    var z = halfPinH; // after bottom half-pin
    for (var ti = 0; ti < numTails - 1; ti++) {
      z += tailH; // skip tail
      pinZs.push([z, z + pinH]);
      z += pinH;
    }
    // Half-pin positions
    var halfPinZs = [[0, halfPinH], [sh - halfPinH, sh]];

    // ---- LEFT SIDE FACE (y=sl) - FRONT CORNER (near x=sw) ----
    // Pins from FRONT wall end grain visible on side face
    for (var i = 0; i < pinZs.length; i++) {
      var pz1 = pinZs[i][0], pz2 = pinZs[i][1];
      var pinPoly = [
        iso(sw, sl, pz1 + taper),
        iso(sw, sl, pz2 - taper),
        iso(sw - st, sl, pz2),
        iso(sw - st, sl, pz1)
      ];
      svg.appendChild(svgEl('polygon', {
        points: pinPoly.map(function(p){return p.join(',')}).join(' '),
        fill: endGrain, stroke: dtStroke, 'stroke-width': 0.6
      }));
    }
    // Half-pins at front corner of side face
    for (var h = 0; h < halfPinZs.length; h++) {
      var hz1 = halfPinZs[h][0], hz2 = halfPinZs[h][1];
      var hp = [
        iso(sw, sl, hz1 + (h === 0 ? 0 : taper * 0.4)),
        iso(sw, sl, hz2 - (h === 0 ? taper * 0.4 : 0)),
        iso(sw - st, sl, hz2),
        iso(sw - st, sl, hz1)
      ];
      svg.appendChild(svgEl('polygon', {
        points: hp.map(function(p){return p.join(',')}).join(' '),
        fill: endGrain, stroke: dtStroke, 'stroke-width': 0.5
      }));
    }

    // ---- LEFT SIDE FACE (y=sl) - BACK CORNER (near x=0) ----
    // Pins from BACK wall end grain visible on side face
    for (var j = 0; j < pinZs.length; j++) {
      var bpz1 = pinZs[j][0], bpz2 = pinZs[j][1];
      var bPinPoly = [
        iso(0, sl, bpz1 + taper),
        iso(0, sl, bpz2 - taper),
        iso(st, sl, bpz2),
        iso(st, sl, bpz1)
      ];
      svg.appendChild(svgEl('polygon', {
        points: bPinPoly.map(function(p){return p.join(',')}).join(' '),
        fill: endGrainDark, stroke: dtStroke, 'stroke-width': 0.5
      }));
    }
    // Half-pins at back corner of side face
    for (var bh = 0; bh < halfPinZs.length; bh++) {
      var bhz1 = halfPinZs[bh][0], bhz2 = halfPinZs[bh][1];
      var bhp = [
        iso(0, sl, bhz1 + (bh === 0 ? 0 : taper * 0.4)),
        iso(0, sl, bhz2 - (bh === 0 ? taper * 0.4 : 0)),
        iso(st, sl, bhz2),
        iso(st, sl, bhz1)
      ];
      svg.appendChild(svgEl('polygon', {
        points: bhp.map(function(p){return p.join(',')}).join(' '),
        fill: endGrainDark, stroke: dtStroke, 'stroke-width': 0.5
      }));
    }

    // ---- Joint lines at corners (vertical seam) ----
    // Front-left corner
    var cFL1 = iso(sw, sl, 0), cFL2 = iso(sw, sl, sh);
    svg.appendChild(svgEl('line', {
      x1: cFL1[0], y1: cFL1[1], x2: cFL2[0], y2: cFL2[1],
      stroke: '#6B4E1B', 'stroke-width': 0.8
    }));
    // Back-left corner
    var cBL1 = iso(0, sl, 0), cBL2 = iso(0, sl, sh);
    svg.appendChild(svgEl('line', {
      x1: cBL1[0], y1: cBL1[1], x2: cBL2[0], y2: cBL2[1],
      stroke: '#6B4E1B', 'stroke-width': 0.6
    }));
    // Front-side seam lines for pin edges
    var cFS1 = iso(sw - st, sl, 0), cFS2 = iso(sw - st, sl, sh);
    svg.appendChild(svgEl('line', {
      x1: cFS1[0], y1: cFS1[1], x2: cFS2[0], y2: cFS2[1],
      stroke: dtStroke, 'stroke-width': 0.3
    }));
    var cBS1 = iso(st, sl, 0), cBS2 = iso(st, sl, sh);
    svg.appendChild(svgEl('line', {
      x1: cBS1[0], y1: cBS1[1], x2: cBS2[0], y2: cBS2[1],
      stroke: dtStroke, 'stroke-width': 0.3
    }));
  })();

  // Wall labels (FRONT, BACK, SIDE)
  var frontCenter = iso(sw, sl / 2, frontH / 2);
  var frontLbl = svgEl('text', {
    x: frontCenter[0], y: frontCenter[1],
    class: 'feature-label', 'font-size': '10px', fill: '#555',
    'text-anchor': 'middle',
    transform: 'rotate(-30,' + frontCenter[0] + ',' + frontCenter[1] + ')'
  });
  frontLbl.textContent = 'FRONT';
  svg.appendChild(frontLbl);

  var backCenter = iso(0, sl / 2, sh / 2);
  var backLbl = svgEl('text', {
    x: backCenter[0], y: backCenter[1],
    class: 'feature-label', 'font-size': '10px', fill: '#888',
    'text-anchor': 'middle',
    transform: 'rotate(-30,' + backCenter[0] + ',' + backCenter[1] + ')'
  });
  backLbl.textContent = 'BACK';
  svg.appendChild(backLbl);

  var sideCenter = iso(sw / 2, sl, sh / 2);
  var sideLbl = svgEl('text', {
    x: sideCenter[0], y: sideCenter[1],
    class: 'feature-label', 'font-size': '10px', fill: '#555',
    'text-anchor': 'middle',
    transform: 'rotate(30,' + sideCenter[0] + ',' + sideCenter[1] + ')'
  });
  sideLbl.textContent = 'SIDE';
  svg.appendChild(sideLbl);

  // Dimension lines for iso view
  // Width along front bottom (y-axis = Width after swap)
  const dw1 = iso(sw, 0, 0), dw2 = iso(sw, sl, 0);
  const dwm1 = [dw1[0] + 15, dw1[1] + 8];
  const dwm2 = [dw2[0] + 15, dw2[1] + 8];
  svg.appendChild(svgEl('line', { x1: dw1[0], y1: dw1[1], x2: dwm1[0], y2: dwm1[1], class: 'dim-line' }));
  svg.appendChild(svgEl('line', { x1: dw2[0], y1: dw2[1], x2: dwm2[0], y2: dwm2[1], class: 'dim-line' }));
  svg.appendChild(svgEl('line', { x1: dwm1[0], y1: dwm1[1], x2: dwm2[0], y2: dwm2[1], class: 'dim-line' }));
  const wLabel = svgEl('text', {
    x: (dwm1[0] + dwm2[0]) / 2 + 8,
    y: (dwm1[1] + dwm2[1]) / 2 - 2,
    class: 'dim-text'
  });
  wLabel.textContent = fmtDim(d.W);
  svg.appendChild(wLabel);
  const wName = svgEl('text', {
    x: (dwm1[0] + dwm2[0]) / 2 + 8,
    y: (dwm1[1] + dwm2[1]) / 2 + 8,
    class: 'dim-text dim-text-small'
  });
  wName.textContent = 'WIDTH';
  svg.appendChild(wName);

  // Length along left side bottom (visible side, y=sl)
  const dl1 = iso(sw, sl, 0), dl2 = iso(0, sl, 0);
  const dlm1 = [dl1[0] - 15, dl1[1] + 8];
  const dlm2 = [dl2[0] - 15, dl2[1] + 8];
  svg.appendChild(svgEl('line', { x1: dl1[0], y1: dl1[1], x2: dlm1[0], y2: dlm1[1], class: 'dim-line' }));
  svg.appendChild(svgEl('line', { x1: dl2[0], y1: dl2[1], x2: dlm2[0], y2: dlm2[1], class: 'dim-line' }));
  svg.appendChild(svgEl('line', { x1: dlm1[0], y1: dlm1[1], x2: dlm2[0], y2: dlm2[1], class: 'dim-line' }));
  const lLabel = svgEl('text', {
    x: (dlm1[0] + dlm2[0]) / 2 - 8,
    y: (dlm1[1] + dlm2[1]) / 2 - 2,
    class: 'dim-text',
    'text-anchor': 'end'
  });
  lLabel.textContent = fmtDim(d.L);
  svg.appendChild(lLabel);
  const lName = svgEl('text', {
    x: (dlm1[0] + dlm2[0]) / 2 - 8,
    y: (dlm1[1] + dlm2[1]) / 2 + 8,
    class: 'dim-text dim-text-small',
    'text-anchor': 'end'
  });
  lName.textContent = 'LENGTH';
  svg.appendChild(lName);

  // Height along front-right vertical
  const dh1 = iso(sw, 0, 0), dh2 = iso(sw, 0, sh);
  const dhOff = 18;
  svg.appendChild(svgEl('line', { x1: dh1[0] + dhOff, y1: dh1[1], x2: dh1[0], y2: dh1[1], class: 'dim-line' }));
  svg.appendChild(svgEl('line', { x1: dh2[0] + dhOff, y1: dh2[1], x2: dh2[0], y2: dh2[1], class: 'dim-line' }));
  svg.appendChild(svgEl('line', { x1: dh1[0] + dhOff, y1: dh1[1], x2: dh2[0] + dhOff, y2: dh2[1], class: 'dim-line' }));
  const hLabel = svgEl('text', {
    x: dh1[0] + dhOff + 4,
    y: (dh1[1] + dh2[1]) / 2,
    class: 'dim-text',
    'text-anchor': 'start'
  });
  hLabel.textContent = fmtDim(d.H);
  svg.appendChild(hLabel);
  const hName = svgEl('text', {
    x: dh1[0] + dhOff + 4,
    y: (dh1[1] + dh2[1]) / 2 + 10,
    class: 'dim-text dim-text-small',
    'text-anchor': 'start'
  });
  hName.textContent = 'HEIGHT';
  svg.appendChild(hName);

  container.appendChild(svg);
}


// ============================================================
// SPEC TABLE
// ============================================================
function updateSpecTable(d) {
  const body = document.getElementById('specBody');
  body.innerHTML = '';

  const rows = [
    ['Width', fmtDim(d.W), 'Pull Cutout', d.pullCutout ? `ON (${fmtDim(d.pullW)} x ${fmtDim(d.pullD)})` : 'OFF'],
    ['Length / Depth', fmtDim(d.L), 'Scoop Front', d.scoopFront ? `ON (${fmtDim(d.scoopD)} deep)` : 'OFF'],
    ['Height', fmtDim(d.H), 'Undermount Notches', d.undermountNotch ? 'ON' : 'OFF'],
    ['Material Thickness', fmtDim(d.T), 'Joinery', 'Dovetail'],
  ];

  for (const r of rows) {
    const tr = document.createElement('tr');
    for (const c of r) {
      const td = document.createElement('td');
      td.textContent = c;
      tr.appendChild(td);
    }
    body.appendChild(tr);
  }
}


// ============================================================
// MAIN UPDATE
// ============================================================
function updateDrawing() {
  const d = getInputs();
  drawTopView(d);
  drawFrontView(d);
  drawIsoView(d);
  updateSpecTable(d);
}

// ============================================================
// FILEMAKER INTEGRATION
// ============================================================
// Call this function from FileMaker to set all values at once.
// In FileMaker, construct your Web Viewer URL like:
//
// "data:text/html," & GetAsURLEncoded(
//   Substitute( YourHTMLField ;
//     ["{{WIDTH}}" ; Width] ;
//     ["{{LENGTH}}" ; Length] ;
//     ["{{HEIGHT}}" ; Height] ;
//     ["{{THICKNESS}}" ; Thickness]
//   )
// )
//
// Or use FileMaker.PerformScript to call back and invoke:
//
//   setFromFileMaker({
//     width: {{WIDTH}},
//     length: {{LENGTH}},
//     height: {{HEIGHT}},
//     thickness: {{THICKNESS}},
//     pullCutout: true,
//     pullWidth: 4,
//     pullDepth: 1.5,
//     scoopFront: true,
//     scoopDepth: 1,
//     undermountNotch: true,
//     orderNumber: "ORD-12345",
//     customerName: "John Smith"
//   });

function setFromFileMaker(params) {
  if (params.width) document.getElementById('dimWidth').value = params.width;
  if (params.length) document.getElementById('dimLength').value = params.length;
  if (params.height) document.getElementById('dimHeight').value = params.height;
  if (params.thickness) document.getElementById('dimThick').value = params.thickness;

  if (params.pullCutout !== undefined) document.getElementById('togPull').checked = params.pullCutout;
  if (params.pullWidth) document.getElementById('pullWidth').value = params.pullWidth;
  if (params.pullDepth) document.getElementById('pullDepth').value = params.pullDepth;

  if (params.scoopFront !== undefined) document.getElementById('togScoop').checked = params.scoopFront;
  if (params.scoopDepth) document.getElementById('scoopDepth').value = params.scoopDepth;

  if (params.undermountNotch !== undefined) document.getElementById('togNotch').checked = params.undermountNotch;

  if (params.orderNumber) {
    document.getElementById('orderDisplay').textContent = 'Order: ' + params.orderNumber;
  }

  updateDrawing();
}

// ============================================================
// URL PARAMETER SUPPORT (for FileMaker file:// approach)
// ============================================================
function loadFromURL() {
  const params = new URLSearchParams(window.location.search);
  if (params.has('width')) {
    setFromFileMaker({
      width: parseFloat(params.get('width')) || 24,
      length: parseFloat(params.get('length')) || 21,
      height: parseFloat(params.get('height')) || 7,
      thickness: parseFloat(params.get('thickness')) || 0.5625,
      pullCutout: params.get('pullCutout') === '1' || params.get('pullCutout') === 'true',
      pullWidth: parseFloat(params.get('pullWidth')) || 4,
      pullDepth: parseFloat(params.get('pullDepth')) || 1.5,
      scoopFront: params.get('scoopFront') === '1' || params.get('scoopFront') === 'true',
      scoopDepth: parseFloat(params.get('scoopDepth')) || 1,
      undermountNotch: params.get('undermountNotch') === '1' || params.get('undermountNotch') === 'true',
      orderNumber: params.get('order') || ''
    });
  }
}

// ============================================================
// INIT
// ============================================================
document.getElementById('dateDisplay').textContent = new Date().toLocaleDateString();
window.addEventListener('resize', updateDrawing);
updateDrawing();
loadFromURL();
</script>
</body>
</html>
